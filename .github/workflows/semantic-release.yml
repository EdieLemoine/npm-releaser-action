name: 'Semantic release'

on:
  push:
    branches:
      - main
      - alpha
      - beta

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: true

jobs:
  release:
    name: 'Release new version ðŸš€'
    runs-on: ubuntu-22.04
    steps:
      - uses: actions/checkout@v3

      - uses: myparcelnl/actions/yarn-install@v3
        with:
          node-version: 18

      - name: 'Disable git push'
        shell: bash
        run: |
          echo '
          function git-without-push() {
              if [[ $@ == *"push"* ]] && [[ ! $@ == *"dry-run"* ]]; then
                echo "git push is disabled"
                return 0
              fi

              command git "$@"
          }

          alias git=git-without-push
          ' >> ~/.bashrc

          cat ~/.bashrc
          
          git push
          git push --dry-run

      - uses: ./semantic-release
        id: release
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          write-summary: true
          semantic-release-args: --debug

      - name: 'Check outputs'
        run: |
          echo ${{ steps.release.outputs.next-version }}
          echo ${{ steps.release.outputs.previous-version }}
          echo ${{ steps.release.outputs.release-type }}
          echo ${{ steps.release.outputs.released }}

      - name: 'Get latest commit hash'
        if: steps.release.outputs.released == 'true'
        id: commit
        run: |
          git log -1

          echo "hash=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
          branch=release/${{ steps.release.outputs.next-version }}"

          echo "branch=$branch" >> $GITHUB_OUTPUT

          git push origin $branch

#      - uses: actions/github-script@v6
#        if: steps.release.outputs.released == 'true'
#        name: 'Create fake check runs'
#        with:
#          github-token: ${{ steps.credentials.outputs.token }}
#          script: |
#            const { data: branch } = await github.rest.repos.getBranch({
#              owner: context.repo.owner,
#              repo: context.repo.repo,
#              branch: context.ref
#            });
#
#            core.info(`Ref: ${context.ref}`);
#            core.info(`Branch: ${JSON.stringify(branch, null, 2)}`);
#
#            // const { data: { required_status_checks: requiredStatusChecks } } = await github.rest.repos.getBranchProtection({
#            //   owner: context.repo.owner,
#            //   repo: context.repo.repo,
#            //   branch: context.ref
#            // });
#
#            if (!branch.protected) {
#              core.info('No branch protection found.');
#              return;
#            }
#
#            const checkNames = branch.protection?.required_status_checks?.checks?.map(check => check.context);
#
#            if (! checkNames) {
#              core.info('No required checks found.');
#              return;
#            }
#
#            core.info(`Required checks: ${checkNames.join(', ')}`);
#
#            await Promise.all(checkNames.map(async name => {
#              core.info(`Creating check: ${name}`);
#              await github.rest.checks.create({
#                owner: context.repo.owner,
#                repo: context.repo.repo,
#                head_sha: '${{ steps.commit.outputs.hash }}',
#                name,
#                status: 'completed',
#                conclusion: 'success',
#              });
#            }));
#
#      - uses: myparcelnl/actions/rebase@v3
#        if: steps.release.outputs.released == 'true'
#        with:
#          token: ${{ steps.credentials.outputs.token }}
#          base: ${{ steps.commit.outputs.branch }}
#          branch: ${{ github.ref }}
#
#      - name: 'Delete created branch'
#        if: steps.release.outputs.released == 'true'
#        run: |
#          git push origin --delete ${{ steps.commit.outputs.branch }}
